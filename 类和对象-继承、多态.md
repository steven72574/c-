## 继承
好处是减少重复的代码。
语法 class 子类（也成为派生类） : 继承方式 父类（基类）
```c++
//以网页举例子，Basepage是每个网页都具有的共同部分
class Basepage
{
public:
	void header()
	{
		cout << "头部标题栏" << endl;
	}
	void left()
	{
		cout << "左侧标题栏" << endl;
	}
	void footer()
	{
		cout << "底部标题栏" << endl;
	}
};

class Java :public Basepage//java 网页继承Basepage的方法
{
public:

	void content()
	{
		cout << "java视频下载" << endl;
	}
};
//语法 class 子类（也成为派生类） : 继承方式 父类（基类）
class Python :public Basepage//java 网页继承Basepage的方法
{
public:
	void content()
	{
		cout << "Python视频下载" << endl;
	}
};
class CPP :public Basepage//java 网页继承Basepage的方法
{
public:
	void content()
	{
		cout << "C++视频下载" << endl;
	}
};

void test()
{
	CPP cpp;
	cpp.header();
	cpp.footer();
	cpp.left();
	cpp.content();

	Java java;
	java.header();
	java.footer();
	java.left();
	java.content();
}
int main() {
	
	test();

	system("pause");
	return 0; 

}
```
### 继承方式
父类中private是不能被子类继承的  
public：父类中的变量，是public的继承后在子类中还是public，protected的还是protected  
protected：父类的public和protected在子类中都变成protected  
private：父类的public和protected在子类中都变成private  
相当于限定了子类继承的是往下限定  
![image](https://user-images.githubusercontent.com/83968454/204673891-8aabcf9e-1601-47d2-884c-4fe50c41d2d3.png)  

### 继承中的对象模型
EP129有教程能看对象模型  
![image](https://user-images.githubusercontent.com/83968454/204675930-314df393-8eca-456d-af97-6fa24aa672ed.png)  

父类中的private成员（非静态的），也会被子类继承，也就是说也会占用字节。访问不到是因为编译器隐藏了，但是实际上是被子类继承了的  
```c++
//以网页举例子
class Basepage
{
public:
	int a;
protected:
	int b;
private:
	int c;
};

class Java :public Basepage//java 网页继承Basepage的方法
{
public:
	int d;
	
};

void test()
{
	Java java;
	cout << sizeof(java) << endl;//输出16
}
int main() {
	
	test();

	system("pause");
	return 0; 

}

```
### 继承中构造和析构的顺序
子类继承父类之后，当创建子类对象时，会创建一个父类对象，因此也会调用父类的构造函数  
问题：父类和子类的构造和析构顺序谁先谁后？
```c++
//以网页举例子
class Basepage
{
public:
	Basepage() {
		cout << "父类构造" << endl;
	}
	~Basepage() {
		cout << "父类析构" << endl;
	}
	int a;
protected:
	int b;
private:
	int c;
};

class Java :public Basepage//java 网页继承Basepage的方法
{
public:
	Java() {
		cout << "子类构造函数" << endl;
	}
	~Java() {
		cout << "子类析构函数" << endl;
	}
	int d;
	
};



void test()
{
	Java java;
	//输出结果
	//父类构造
	//子类构造函数
	//子类析构函数
	//父类析构
	
}
int main() {
	
	test();

	system("pause");
	return 0; 

}

```
### 同名成员处理
假设子类和父类中，m_age成员变量重名了，若是访问子类则直接访问，若是访问父类则加一个作用域  
同名函数同理，要注意，如果子类出现和父类同名的成员函数，则子类的同名函数会隐藏掉父类中所有的同名函数。因此也要通过声明作用域的方式调用父类的该重载的同名函数。
```
//以网页举例子
class Basepage
{
public:
	void print() {
		cout << "调用了父类的同名函数" << endl;
	}
	int m_num = 20;

	void print(int num) {
		cout << "父类的同名函数被重载."<<num << endl;
	}
protected:
	int b;
private:
	int c;
};

class Java :public Basepage//java 网页继承Basepage的方法
{
public:
	void print() {
		cout << "调用了子类的同名函数" << endl;
	}
	
	int m_num = 100;
	
};



void test()
{
	Java java;
	cout << java.m_num << endl;//子类的数据
	cout << java.Basepage::m_num << endl;//父类的数据
	java.print();//子类函数
	java.Basepage::print();//父类函数
	java.Basepage::print(100);//调用父类重载的函数
}
int main() {
	
	test();

	system("pause");
	return 0; 

}
```
### 同名的静态成员处理方式
和同名的非静态成员处理方式一致  
```c++
//以网页举例子
class Basepage
{
public:
	void print() {
		cout << "调用了父类的同名函数" << endl;
	}
	
	void print(int num) {
		cout << "父类的同名函数被重载."<<num << endl;
	}
	static int m_num;

};
int Basepage::m_num = 100;
class Java :public Basepage//java 网页继承Basepage的方法
{
public:
	void print() {
		cout << "调用了子类的同名函数" << endl;
	}
	
	static int m_num;
	
};

int Java::m_num = 200;

void test()
{
	Java java;
	//一、访问静态变量有两种方式
	//1.通过对象访问
	cout << java.m_num << endl;//子类
	cout << java.Basepage::m_num << endl;//父类

	//2.通过类名访问
	cout << Java::m_num << endl;//子类
	cout << Java::Basepage::m_num << endl;//父类************，这里的访问语法是要注意的
	//第一个::是说明通过类名的方式访问，第二个::代变通过父类作用域下  

	//二、访问静态方法和上面一样。
	//同样，子类若有同名的静态函数，则父类中所有同名静态函数会被隐藏
}
int main() {
	
	test();

	system("pause");
	return 0; 

}
```
### 多继承语法
一个类继承多个类  
class 子类:继承方式 父类1，继承方式 :父类2...  
__若几个父类中有同名成员，则要加作用域__，实际开发中不建议使用多继承  
### 菱形继承（钻石继承）问题以及解决方法  
下图为菱形继承，即两个子类继承同一个父类，而另外一个类继承了这两个子类。  
![image](https://user-images.githubusercontent.com/83968454/204802254-80ba9e07-c97d-41c0-b3bd-d58aca9516ac.png)  
这直接存在的问题：  
1.羊继承了动物类，驼同样也继承了动物类，当草泥马使用数据时，会产生二义性  
2.草泥马继承自动物的数据中有两份，但是我们知道，这份数据我们只需要一份就可以  
![image](https://user-images.githubusercontent.com/83968454/204802617-d2aa1169-6c5d-4af8-b37a-96c2fcb4975c.png)  

### 画对象内存图
在上方右键当前文件，可以打开当前文件夹路径  -->  复制路径 --> visual studio 2019 下的开发人员的命令提示符(Developer Command Prompt for VS2019)  
--> 跳转盘符(输入D:) --> cd 代码文件夹所在路径 --> 命令行输入dir 显示当前文件夹的文件  
--> 输入cl /d1 reportSingleClassLayoutSheepCamel hello_world.cpp (注意cl是字母，d1后面是数字一，语法格式，reportSingleClassLayout+类名 文件名)  
菱形继承对象模型  
![image](https://user-images.githubusercontent.com/83968454/204807107-95e8c6bb-73ff-414d-9949-4b6e303074bf.png)  
虚继承的对象模型  
vbptr：virtual Base Pointer 虚基类指针  
工作原理：Sheep类的vbptr指向一个vbtable@Sheep@,即图中箭头显示。表中会记录指针的偏移量，如sheep类中记录的偏移量为8，因此往下偏移8个字节，找到m_Age.同理Camel类也是指向m_Age.
因此不管是Sheep继承的m_Age还是Camel继承的m_Age，这个数据都是共享同一份数据。
![image](https://user-images.githubusercontent.com/83968454/204807978-f5d66cf3-514e-48b1-bfa2-8418eebc37b8.png)
  


