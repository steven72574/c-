## 继承
好处是减少重复的代码。
语法 class 子类（也成为派生类） : 继承方式 父类（基类）
```c++
//以网页举例子，Basepage是每个网页都具有的共同部分
class Basepage
{
public:
	void header()
	{
		cout << "头部标题栏" << endl;
	}
	void left()
	{
		cout << "左侧标题栏" << endl;
	}
	void footer()
	{
		cout << "底部标题栏" << endl;
	}
};

class Java :public Basepage//java 网页继承Basepage的方法
{
public:

	void content()
	{
		cout << "java视频下载" << endl;
	}
};
//语法 class 子类（也成为派生类） : 继承方式 父类（基类）
class Python :public Basepage//java 网页继承Basepage的方法
{
public:
	void content()
	{
		cout << "Python视频下载" << endl;
	}
};
class CPP :public Basepage//java 网页继承Basepage的方法
{
public:
	void content()
	{
		cout << "C++视频下载" << endl;
	}
};

void test()
{
	CPP cpp;
	cpp.header();
	cpp.footer();
	cpp.left();
	cpp.content();

	Java java;
	java.header();
	java.footer();
	java.left();
	java.content();
}
int main() {
	
	test();

	system("pause");
	return 0; 

}
```
### 继承方式
父类中private是不能被子类继承的  
public：父类中的变量，是public的继承后在子类中还是public，protected的还是protected  
protected：父类的public和protected在子类中都变成protected  
private：父类的public和protected在子类中都变成private  
相当于限定了子类继承的是往下限定  
![image](https://user-images.githubusercontent.com/83968454/204673891-8aabcf9e-1601-47d2-884c-4fe50c41d2d3.png)  

### 继承中的对象模型
EP129有教程能看对象模型  
![image](https://user-images.githubusercontent.com/83968454/204675930-314df393-8eca-456d-af97-6fa24aa672ed.png)  

父类中的private成员（非静态的），也会被子类继承，也就是说也会占用字节。访问不到是因为编译器隐藏了，但是实际上是被子类继承了的  
```c++
//以网页举例子
class Basepage
{
public:
	int a;
protected:
	int b;
private:
	int c;
};

class Java :public Basepage//java 网页继承Basepage的方法
{
public:
	int d;
	
};

void test()
{
	Java java;
	cout << sizeof(java) << endl;//输出16
}
int main() {
	
	test();

	system("pause");
	return 0; 

}

```
### 继承中构造和析构的顺序
子类继承父类之后，当创建子类对象时，会创建一个父类对象，因此也会调用父类的构造函数  
问题：父类和子类的构造和析构顺序谁先谁后？
```c++
//以网页举例子
class Basepage
{
public:
	Basepage() {
		cout << "父类构造" << endl;
	}
	~Basepage() {
		cout << "父类析构" << endl;
	}
	int a;
protected:
	int b;
private:
	int c;
};

class Java :public Basepage//java 网页继承Basepage的方法
{
public:
	Java() {
		cout << "子类构造函数" << endl;
	}
	~Java() {
		cout << "子类析构函数" << endl;
	}
	int d;
	
};



void test()
{
	Java java;
	//输出结果
	//父类构造
	//子类构造函数
	//子类析构函数
	//父类析构
	
}
int main() {
	
	test();

	system("pause");
	return 0; 

}

```
### 同名成员处理
假设子类和父类中，m_age成员变量重名了，若是访问子类则直接访问，若是访问父类则加一个作用域  
同名函数同理，要注意，如果子类出现和父类同名的成员函数，则子类的同名函数会隐藏掉父类中所有的同名函数。因此也要通过声明作用域的方式调用父类的该重载的同名函数。
```
//以网页举例子
class Basepage
{
public:
	void print() {
		cout << "调用了父类的同名函数" << endl;
	}
	int m_num = 20;

	void print(int num) {
		cout << "父类的同名函数被重载."<<num << endl;
	}
protected:
	int b;
private:
	int c;
};

class Java :public Basepage//java 网页继承Basepage的方法
{
public:
	void print() {
		cout << "调用了子类的同名函数" << endl;
	}
	
	int m_num = 100;
	
};



void test()
{
	Java java;
	cout << java.m_num << endl;//子类的数据
	cout << java.Basepage::m_num << endl;//父类的数据
	java.print();//子类函数
	java.Basepage::print();//父类函数
	java.Basepage::print(100);//调用父类重载的函数
}
int main() {
	
	test();

	system("pause");
	return 0; 

}
```
### 同名的静态成员处理方式
和同名的非静态成员处理方式一致  
```c++
//以网页举例子
class Basepage
{
public:
	void print() {
		cout << "调用了父类的同名函数" << endl;
	}
	
	void print(int num) {
		cout << "父类的同名函数被重载."<<num << endl;
	}
	static int m_num;

};
int Basepage::m_num = 100;
class Java :public Basepage//java 网页继承Basepage的方法
{
public:
	void print() {
		cout << "调用了子类的同名函数" << endl;
	}
	
	static int m_num;
	
};

int Java::m_num = 200;

void test()
{
	Java java;
	//一、访问静态变量有两种方式
	//1.通过对象访问
	cout << java.m_num << endl;//子类
	cout << java.Basepage::m_num << endl;//父类

	//2.通过类名访问
	cout << Java::m_num << endl;//子类
	cout << Java::Basepage::m_num << endl;//父类************，这里的访问语法是要注意的
	//第一个::是说明通过类名的方式访问，第二个::代变通过父类作用域下  

	//二、访问静态方法和上面一样。
	//同样，子类若有同名的静态函数，则父类中所有同名静态函数会被隐藏
}
int main() {
	
	test();

	system("pause");
	return 0; 

}
```
