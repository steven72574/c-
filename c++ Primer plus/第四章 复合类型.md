### 数组
编译器不会检查下标是否越界，这个需要我们确保使用的下标是有效的。  
数组创建之后，如果没有初始化，则其值是不确定的，为以前驻留在该单元中的值（而java会初始化为0）  
若要将一个数组的元素都设置为0，可以按下面来做。  
因为如果提供的初始化列表的元素个数少于数组的长度的话，其会默认将剩下的元素设置为0  
```c++
int nums[10] = {0};
```

注意，不能将一个数组赋给另一个数组（java可以）  
```c++
int nums[5] = { 1 ,2 ,3 ,4 ,5};
int another_nums[5];
another_nums[5] = {7, 8, 9, 10, 11};//不允许的
another_nums = nums;//不允许的
```
c++11后，数组初始化能够省略 = 等号。以及列表为空也能将数组元素都设置为0  
```c++
int nums[10] = {};
int numsa[2] { 4 , 2};
```
vector能够替代数组，c++11新增了模板类array。  

### 字符串类

用sizeof 计算c风格的数组其数组长度要加结尾的\0,也就是其字符长度加1  
```c++
char c[] = "I m a boy.";
cout << sizeof c << endl;//输出11
```

cin 使用空白（空格，制表符和换行符）来确定字符串的结束位置，因此下列程序可能造成意想不到

### 指针
OOP强调的是在运行阶段进行决策，而不是在编译阶段进行决策，比如数组的长度必须事先指定，因此，数组长度在编译时就设定好了，这就是编译阶段决策。  
使用OOP时，要在运行阶段进行决策，则可以用new创建数组。  
new要和delete搭配使用  
```c++
int* p1,p2;//创建了一个指针 p1 和一个int变量 p2
//p1的类型是是指向int的指针 或 p1的类型是 int*型
```
注意：指针在被\*解引用前一定要初始化
```c++
int* pt = new int;//用new申请一块内存地址，并赋给pt指针
```
常规变量声明存储在栈区，而new声明的内存在堆区，或叫自由存储区。  
空指针，值为0的指针，确保其不会指向有效数据。  
内存分配也可能失败，当内存不足的时候，new会返回0.而c++提供了检测并处理内存分配失败的工具（后面会说）  
```c++
int* pt = 0;//空指针
delete pt;
```
__delete__：会释放指向的内存，但是不会删除pt指针本身，因此后面可以继续使用pt指向新的内存块。  
new和delete要配对使用，否则将发生内存泄漏，也就是说，被分配的内存再也无法使用。  
不要释放已经释放的内存块，也不要释放声明变量获得的内存。  
对空指针使用delete是安全的  
一般来说，对大型数据（数组，结构体，字符串）才使用指针，单一变量一般不适用指针  

静态联编：在编译时给数组分配内存  
动态联编：在运行时给数组分配内存  
用new创建动态数组,sizeof在这里只能返回数组第一个元素的大小而不是整个数组的大小  
__数组名和指针的根本差别__
1.sizeof数组名是整个数组的长度，而sizeof指针则是第一个元素的大小  
```c++
int arr[] = {1,2,3}
arr = arr + 1;//错误
cout << arr + 1 << endl;//输出第二个元素的地址
int* pt = new int[] {1,2,3};
pt = pt + 1;//正确
```
```c++
int* arr = new int[10]{1,2};
arr[1];//可以直接当作数组访问
arr = arr + 1;//向后访问四个字节，取下一个元素值,但此时arr[0]变成了2而不是1.
int* pt = new int(2);
pt[1];//也能访问其后面的内存，但此时值为之前内存中遗留下来的值
```
new和delete使用规则  
![image](https://user-images.githubusercontent.com/83968454/209872994-525b099e-4018-4a1e-ae15-6864fbdb5fb7.png)  

数组的地址
```c++
int arr[10];
cout << arr<< endl; //输出 &arr[0]
cout << &arr << endl; //输出整个数组的地址
//以上两个输出其结果是一样的
//但是 arr + 1,其会往后移动 4 字节
//而 &arr + 1 会往后移动 40 字节
```
p109比较绕，关于储存20个指针的指针数组和一个指向含有20个元素数组的指针。  

