p341
### 封装
类中的公有成员函数是类的接口（外部与类通信的方式），而私有成员函数则是类中不属于公有接口的部分。
下面三个都是封装的例子  
1.通常将接口（类定义）放在头文件中，将实现（类方法的代码）放在源代码文件中,注意，源文件要#include 头文件.h。  
2.数据隐藏：将数据放在类的私有部分中（private）  
3.将方法私有化，对外隐藏实现的细节  

数据隐藏是OOP面向对象编程的主要目标之一，因此数据通常都是private属性  

下面是成员函数,Stock表明update()方法是Stock类的方法，update此时具有Stock类作用域，在该类其他方法中，可以不用作用域解析符就访问update。  
```c++
void Stock::update(double price){}
```
当一个类对象（实例化对象）调用成员函数时，它将被用来调用它的对象的数据成员。  
创建类对象的两种方法：
```c++
Stock s("小明",23,20);//声明类变量
//new
```

### 客户/服务器模型  
OOP程序员常依照客户/服务器模型来设计程序。使用类的那些方法是客户，而类声明以及实现构成了服务器。其中，客户（程序，或别的方法）
通过类的接口使用服务器。对于客户来说，唯一责任是了解该接口的功能并且可靠执行，而服务器（服务器设计人员）的责任是确保服务器能够根绝
该接口可靠准确得执行。且维护时，服务器（类）只能修改实现细节，而不能修改对外得接口，这样修改服务器的代码不会对客户造成意外影响。

注意的小细节：书中在show()成员函数中修改了cout的参数，使其避免用科学计数法打印。因为cout参数修改是持续的，后续没有其他修改时，则会保持这个状态，因此修改完cout的参数之后，记得在show()结束时，将cout的参数修改回来，避免后续其他程序使用时出现错误，

### 为什么要有构造函数
```c++
struct person{
      string name;
      int age;
}
class Student{
  string name;
  int ID;
}
int main(){
  person p = {"小明",25};
  Student s = {"小红",14665};//不合法，因为Student的属性默认为private，如果将其属性变为public则可以像上面结构体那样声明，但是这违背了数据隐藏的原则。
                             //因此通过类的成员函数——构造函数来将类的属性初始化。
  
  return 0;
}
```
构造函数参数与成员命名常见规则：成员属性命名前加m_ ,或在其后加_
```c++
int m_age;
int age_;
```
构造函数的调用：
```c++
Stock a = Stock("company A" , 0 , 0);//显示调用，可以看成是调用Stock函数。
Stock b("company B" , 0 , 0);//隐式调用
Stock* pstock = new Stock("company C" , 0 ,0);
//创建了一个Stock对象，有company C 等的属性，然后把该对象地址赋给pstock指针,此时，对象没有名字，但是可以通过该指针操控对象的数据。
```
默认构造函数：下面为默认构造函数，下面的声明会调用默认构造函数。  
```c++
Stock::Stock(){};
Stock astock;
```

定义默认构造函数
```c++
//1.给已有的构造函数的所有参数提供默认值
Stock::Stock(const string& co="Error" , int n = 0 , double pr = 0.0)
{
}
//2.没有参数的构造函数
Stock::Stock(){
}

```
如果为类定义了非默认构造函数的话，系统则不会定义默认构造函数，必须程序员手动定义，否则默认声明会报错  
一般来说，最好定义一个默认构造函数为类的所有属性隐式地提供初始值，不容易出错。

### 析构函数
如果构造函数使用new分配了内存，则在析构函数要给他释放掉。  
析构函数何时被调用？由编译器决定（不明白静态存储类和自动存储类P356，先跳过）：  
1.如果是用new创建了一个对象，则delete这个对象之后会调用该对象的析构函数；  
2.如果是静态存储类对象，则程序结束时自动调用析构函数。  
3.如果是自动存储类对象，程序执行完代码块时调用析构函数。  
4.对于临时对象，程序对该对象结束使用时调用析构函数。  


```c++
//Stock(string company , int num , double price)
Stock s1 = Stock("company a", 0 , 0.0);//初始化s1，可能创建临时对象，也可能不会，由编译器决定。这种方法效率更高
s1 = Stock("company b" , 0 , 0.0);//创建一个临时对象，然后将该临时对象的成员属性复制给s1，紧接着该临时对象被销毁，析构函数被调用

```

```c++

const Stock s1 = Stock("company" , 0 , 0.0);
s1.show();//这个会报错，因为show()方法不能保证该对象不被修改，定义为常函数能够解决这个问题
void show() const;
```

### 类和对象数组
初始化对象数组时，首先使用默认构造函数创建数组元素，然后使用花括号中的构造函数创建临时对象，然后将临时对象赋值到数组相应的元素中，因此要创建对象数组，这个类必须有默认构造函数。  
```c++
Stock sarray[10];//声明了一个对象数组，每个对象调用默认构造函数
//初始化数组的每个对象
Stock sarray[3] = { 
      Stock("comapny a" , 1 , 2.0),
      Stock(),
};
```
### 作用域为类的常量
如果想定义一个常量，且该常量的作用域为类，有两种方法：
```c++
enum {Months = 12};//1定于为枚举
static const in Month = 12;//用static
```
