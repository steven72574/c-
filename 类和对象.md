## 1.内存分区
c++程序执行时，将内存大方向分为四个区域
1.代码区，存放函数体的二进制代码，由操作系统进行管理的  
2.全局区：存放全局变量(__全局变量__ 是不在任何函数声明中的，并且被所有函数共享) 和静态变量(如static int)以及常量  
__常量分为下面几类__ ：
字符串常量 
const修饰的全局变量  
const修饰的局部变量(不在全局区，在栈区)  
3.栈区：由编译器自动分配和释放，存放函数的参数值，局部变量等（不要返回局部变量的地址，因为函数执行完后，该局部变量的内存会被释放）  
4.堆区：由程序员分配和释放(__new__ 关键字)，若程序员不释放，程序结束时由操作系统回收  
```c++
new int(10);//返回的是开辟的内存的地址，可以用指针变量进行存储
int* p = new int(10);//这个内存地址可以被函数返回
delete p; //释放这段内存
int* arr = new int[10];//创建一个有十个元素的数组,并将头元素的内存地址传给arr指针
delete[] arr; //释放数组时，加中括号
```
意义：
程序编译后，生成了exe可执行程序，未执行该程序之前分只为两个区域，程序运行后才会有栈区和堆区    
__代码区__：
是共享的，对于频繁被执行的程序，只需要在内存中有一份代码即可。
是只读的，防止程序意外修改了代码。

__全局区__：
全局变量，静态变量，常量区，字符串常量和其他常量  
该区域的数据在程序结束后由操作系统释放  

## 引用
引用就是给变量起别名。
语法： int& 别名 = 原名  
```c++
//引用的注意事项
	int a = 40;
	int& b = a;
	int& c;//错误的，引用必须初始化
	b = a;//是赋值，不是改引用，引用之后不能更改
```
### 利用引用进行地址传递

```c++
//引用做参数，调用时不需要读地址
//Swap(a,b);
void Swap(int& a, int& b) {
	int temp = a;
	a = b;
	b = temp;
}
//地址传递，调用时要传入地址
//Swap(&a , &b)
void Swap(int* a, int* b) {
	int temp = *a;
	*a = *b;
	*b = temp;
}
```
不要返回局部变量的引用，如下，是不对的  
```c++
int& getnum(){
	int a = 10;
	return a;
}
```
函数的调用也可以是左值，当函数值返回引用的时候，就变成赋值操作  
```c++
int& getnum() {
	static int a = 10;
	return a;
}

int main() {
	int& b = getnum();//b值为10
	getnum() = 100;
	cout << "b=" << b << endl;//b值为100

	system("pause");
	return 0; 
}
```
### 引用的本质
在c++内部实现是一个指针常量  
```c++
int a = 10;
//发现是引用，自动转换为int* const ref = &a;
int& ref = a;

ref = 20; //内部发现ref是引用，自动转换为 *ref = 20;
```
```c++
//发现是引用，自动转换为 int* ref = &a;
void changeNum(int& ref) {
	ref = 20;
}

int main() {
	int a = 10;

	changeNum(a);
	cout << a << endl;//a = 20

	system("pause");
	return 0; 
}
```
### 常量引用
用来修饰形参，防止误操作，防止函数修改传入的参数值（和const int* a 一样的功能）
void getnum(const int& ref){} //相当于 const int* const ref = a; 即不能改变ref对应得值，也不能将ref指向其他地址
### 函数进阶
函数的参数在定义时可以设置默认值，java不可以  
```c++
#include <iostream>
using namespace std;
#include "Headers.h";

//传入参数缺少时，使用默认值
//**注意事项:
//1.若b有默认参数了，则b后面的参数也必须有默认参数
//2.若函数的声明中有默认参数，则后面函数的实现不能有默认参数
int Sum(int a, int b = 20, int c = 30);//函数的声明以及有默认参数了

int Sum( int a , int b , int c) {
	
	return a + b + c;

}

int main() {
	
	int a = Sum(20);
	cout << a << endl;

	system("pause");
	return 0; 
}
```
### 占位参数
```c++
//函数的占位参数，后面会用到
//占位参数也可以有默认参数
int Sum( int a , int  , int =10 ) {
	
	cout << "Sum函数被调用" << endl;
	
	return a;
}

int main() {
	
	int a = Sum(20 , 20 );//调用时，占位参数要用实参填补
	cout <<"a = " << a << endl;

	system("pause");
	return 0; 
}
```
### 函数的重载
函数名可以相同，提高复用性  
函数重载满足条件:   
1.在同一个 __作用域__ 下  
2.函数名相同  
3.函数 __参数类型__ 不同，或 __参数个数__ 不同，或 __参数顺序__ 不同  
注意：
1.函数的返回值不可以作为函数重载条件，若函数名相同，参数类型相同，参数个数相同，参数顺序相同，则运行时会出错    
__当函数重载有引用时__,有const和无const是两种不同类型的参数，可以发生函数重载  
```c++

int Sum( int& a ) {
	
	cout << "int& a" << endl;
	
	return a;
}
//这个函数可以直接传入常量 10，因为编译器会把这个语句优化
//int temp = 10;
//const int& a = temp;
int Sum(const int& a ) {
	cout << "const int& a" << endl;
	return 0;
}
```
